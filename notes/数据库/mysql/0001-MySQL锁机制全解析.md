---
title: MySQL 锁机制全解析
description: 全面介绍 MySQL 中的锁：按粒度、操作类型、用途场景及实现方式分类
category: 数据库
tag:
  - MySQL
  - 数据库底层
---

# MySQL锁机制全解析

在并发控制中，锁是保证数据一致性和完整性的核心机制。MySQL 中的锁种类繁多，为了方便记忆和理解，我们可以从五个维度进行分类。

::: info 提示
本文主要基于 **InnoDB** 存储引擎进行讲解，因为它是目前 MySQL 最主流的存储引擎。
:::

## 1. 按锁定粒度分类 (Granularity)

根据锁定的数据范围大小，可以分为以下四类：

| 锁类型 | 描述 | 特点 |
| :--- | :--- | :--- |
| **全局锁 (Global Lock)** | 锁定整个数据库实例。 | 常用于全库逻辑备份（FTWRL）。 |
| **表级锁 (Table Lock)** | 锁定整张表。 | 开销小，粒度大，容易发生锁冲突，并发度低。 |
| **页级锁 (Page Lock)** | 锁定一组记录所在的页（B+树节点）。 | 介于表锁和行锁之间，仅在 BDB 等引擎中见。 |
| **行级锁 (Row Lock)** | 锁定单行记录。 | 开销大，粒度细，并发度最高，由 InnoDB 实现。 |

## 2. 按操作类型分类 (Operation)

这是最基础的分类，决定了读写操作是否互斥：

- **共享锁 (Shared Lock, S锁)**：又称读锁。允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。
    - `SELECT ... LOCK IN SHARE MODE;`
- **独占锁 (Exclusive Lock, X锁)**：又称写锁。允许获取锁的事务更新或删除数据，阻止其他事务获取相同数据集的 S 锁和 X 锁。
    - `SELECT ... FOR UPDATE;` 或 DML 语句（Insert/Update/Delete）。

## 3. 按用途场景分类 (Scenario)

这是 InnoDB 实现并发控制的核心，特别是针对幻读（Phantom Read）的解决。

### 记录锁 (Record Lock)
仅锁定单行索引记录。例如 `WHERE id = 1 FOR UPDATE` 且 id 是主键。

### 间隙锁 (Gap Lock)
锁定索引记录之间的间隙，不包含记录本身。目的是为了防止其他事务在间隙中插入数据，从而避免幻读。

### 临键锁 (Next-Key Lock)
**Record Lock + Gap Lock** 的结合。既锁定记录本身，又锁定记录前的间隙。InnoDB 默认的行锁算法。

### 意向锁 (Intention Lock)
属于表锁。当事务准备给行加 S 锁或 X 锁时，必须先取得表的意向锁（IS 或 IX）。
- **作用**：让表锁能快速判断表中是否有行被锁定，而不需要逐行扫描。

### 插入意向锁 (Insert Intention Lock)
一种特殊的间隙锁。在插入行之前，由 `INSERT` 操作设置。如果多个事务在同一个间隙插入但位置不同，它们不会互相阻塞。

### 自增锁 (Auto-Inc Lock)
特殊的表级锁。当表中有 `AUTO_INCREMENT` 列时，事务插入数据时会获取该锁，以保证自增序列的连续性。

### 元数据锁 (Metadata Lock, MDL)
当对表执行 DDL 操作（如修改表结构）时，会自动获取 MDL 写锁；当执行 DML/DQL 时，获取 MDL 读锁。防止在查询时表结构被修改。

---

## 4. 按实现方式分类 (Implementation)

这更多是一种程序设计思想：

- **悲观锁 (Pessimistic Locking)**：
    - 假定冲突一定会发生。在操作数据前先加锁（如 `SELECT ... FOR UPDATE`）。
    - 适合写多读少的场景。
- **乐观锁 (Optimistic Locking)**：
    - 假定冲突不会发生。不加物理锁，而是通过版本号（Version）或时间戳来检测冲突。
    - 适合读多写少的场景，减少数据库开销。

---

## 5. 按作用对象分类 (Object)

在内核开发和底层调优中经常提到的概念：

- **Lock (锁)**：
    - 作用于**数据库内容**（行、表、意向锁）。
    - 持续时间长（整个事务期间）。
    - 有死锁检测机制。
- **Latch (闩锁)**：
    - 作用于**内存数据结构**（如 LRU 链表、Buffer Pool）。
    - 锁定时间极短（纳秒/微秒级）。
    - 分为 Mutex（互斥量）和 RW-Lock（读写锁），没有死锁检测。

---

## 总结：锁的兼容性矩阵

| | S 锁 | X 锁 | IS 锁 | IX 锁 |
| :---: | :---: | :---: | :---: | :---: |
| **S** | 兼容 | 不兼容 | 兼容 | 不兼容 |
| **X** | 不兼容 | 不兼容 | 不兼容 | 不兼容 |
| **IS** | 兼容 | 不兼容 | 兼容 | 兼容 |
| **IX** | 不兼容 | 不兼容 | 兼容 | 兼容 |

::: warning 注意
表级意向锁（IS/IX）之间是互相兼容的，因为它们只表示“意向”，真正的冲突发生在行级别。
:::

---
**参考资料：**
- [MySQL 官方文档 - InnoDB Locking](https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html)